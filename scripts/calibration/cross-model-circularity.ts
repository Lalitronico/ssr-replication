/**
 * Cross-Model Circularity Experiment — GPT-4o Rating Claude-Generated Text
 *
 * Tests whether the variance compression and directional bias observed in the
 * circularity experiment (Experiment 4) are artifacts of within-model circularity
 * or general properties of LLM-based rating.
 *
 * Design:
 *   - Load 345 texts generated by Claude Haiku 4.5 (from self-rating experiment)
 *   - Rate all 345 with GPT-4o (cross-model condition)
 *   - Compare distributions:
 *     - Within-model: Claude→Claude (existing data from circularity experiment)
 *     - Cross-model:  Claude→GPT-4o (this experiment)
 *     - Independent:  Claude→SSR (existing data from circularity experiment)
 *
 * If circularity is real:
 *   - Cross-model should show LESS variance compression than within-model
 *   - Cross-model error patterns should be more similar to SSR than to within-model
 *
 * If within-model = cross-model:
 *   - The observed effects are general LLM properties, not circularity artifacts
 *
 * Usage:
 *   npx tsx research/calibration/cross-model-circularity.ts
 *
 * Environment variables required (.env.local):
 *   OPENAI_API_KEY — for GPT-4o
 */

import { config } from "dotenv";
config({ path: ".env.local" });

import * as fs from "fs";
import * as path from "path";

// ─── Configuration ───────────────────────────────────────────────

const GPT_MODEL = "gpt-4o";
const TEMPERATURE = 0;
const MAX_RETRIES = 3;
const DELAY_MS = 300;

// ─── Types ───────────────────────────────────────────────────────

interface GeneratedText {
  testCaseLabel: string;
  domain: string;
  difficulty: string;
  targetRating: number;
  personaId: string;
  personaName: string;
  questionText: string;
  generatedText: string;
}

interface CircularityCase {
  testCaseLabel: string;
  domain: string;
  difficulty: string;
  targetRating: number;
  personaId: string;
  personaName: string;
  questionText: string;
  generatedText: string;
  llmRating: number;
  llmConfidence: number;
  ssrRating: number;
  ssrConfidence: number;
  ssrDistribution: number[];
  ssrRawSimilarities: number[];
}

interface ConditionMetrics {
  n: number;
  exactMatch: number;
  exactMatchPct: number;
  withinOne: number;
  withinOnePct: number;
  mae: number;
  meanSignedError: number;
  sdError: number;
  variance: number;
}

// ─── Helpers ─────────────────────────────────────────────────────

function delay(ms: number): Promise<void> {
  return new Promise((r) => setTimeout(r, ms));
}

function getDataDir(): string {
  return path.join(__dirname, "..", "data");
}

function findLatestFile(prefix: string): string | null {
  const dir = getDataDir();
  if (!fs.existsSync(dir)) return null;
  const files = fs
    .readdirSync(dir)
    .filter((f) => f.startsWith(prefix) && !f.includes("-partial-") && f.endsWith(".json"))
    .sort()
    .reverse();
  return files.length > 0 ? path.join(dir, files[0]) : null;
}

function pad(str: string, len: number): string {
  return str.length >= len ? str : str + " ".repeat(len - str.length);
}

// ─── Prompt (same as-deployed prompt used in circularity experiment) ──

function buildRatingPrompt(questionText: string, responseText: string): string {
  return `Analyze the following survey response and determine the appropriate rating.

Question: "${questionText}"

Response: "${responseText}"

Scale: 1 to 5
This is a Likert scale where 1 = Strongly Disagree/Very Negative and 5 = Strongly Agree/Very Positive.

IMPORTANT: If the response explicitly mentions a specific number (e.g. "I'd give it a 7", "maybe a 4"), use that number as the rating. Only infer from sentiment if no explicit number is stated.

Based on the sentiment and content of the response, provide:
1. A rating from 1 to 5
2. Your confidence level (0.0 to 1.0)

Respond ONLY in this exact JSON format:
{"rating": <number>, "confidence": <number>}`;
}

// ─── GPT-4o API ──────────────────────────────────────────────────

async function callGPT(apiKey: string, prompt: string): Promise<string> {
  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: GPT_MODEL,
      messages: [{ role: "user", content: prompt }],
      temperature: TEMPERATURE,
      max_tokens: 100,
    }),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`OpenAI API error (${response.status}): ${errorBody}`);
  }

  const data = await response.json();
  return data.choices?.[0]?.message?.content || "";
}

// ─── Metrics ─────────────────────────────────────────────────────

function computeMetrics(ratings: number[], targets: number[]): ConditionMetrics {
  const n = ratings.length;
  const errors = ratings.map((r, i) => r - targets[i]);
  const absErrors = errors.map(Math.abs);
  const exact = absErrors.filter((e) => e === 0).length;
  const withinOne = absErrors.filter((e) => e <= 1).length;
  const mae = absErrors.reduce((a, b) => a + b, 0) / n;
  const meanSigned = errors.reduce((a, b) => a + b, 0) / n;
  const variance = errors.reduce((sum, e) => sum + (e - meanSigned) ** 2, 0) / n;

  return {
    n,
    exactMatch: exact,
    exactMatchPct: Math.round((exact / n) * 100),
    withinOne,
    withinOnePct: Math.round((withinOne / n) * 100),
    mae: parseFloat(mae.toFixed(3)),
    meanSignedError: parseFloat(meanSigned.toFixed(3)),
    sdError: parseFloat(Math.sqrt(variance).toFixed(3)),
    variance: parseFloat(variance.toFixed(4)),
  };
}

// ─── Main ────────────────────────────────────────────────────────

async function main() {
  const openaiKey = process.env.OPENAI_API_KEY;
  if (!openaiKey) {
    console.error("ERROR: OPENAI_API_KEY not set in .env.local");
    process.exit(1);
  }

  // ─── Load existing data ────────────────────────────────────────
  const circularityFile = findLatestFile("circularity-results-");
  if (!circularityFile) {
    console.error("ERROR: No circularity-results-*.json found. Run self-rating-experiment.ts first.");
    process.exit(1);
  }

  const circularityData = JSON.parse(fs.readFileSync(circularityFile, "utf-8")) as {
    metadata: any;
    cases: CircularityCase[];
    summary: any;
  };

  console.log("=".repeat(80));
  console.log("CROSS-MODEL CIRCULARITY EXPERIMENT");
  console.log("GPT-4o Rating Claude-Generated Text (N=345)");
  console.log("=".repeat(80));
  console.log(`Date: ${new Date().toISOString()}`);
  console.log(`Source: ${path.basename(circularityFile)}`);
  console.log(`Cases: ${circularityData.cases.length}`);
  console.log(`Rating model: ${GPT_MODEL} (temperature=${TEMPERATURE})`);
  console.log(`Generation model: ${circularityData.metadata.config.generationModel}`);
  console.log("=".repeat(80));
  console.log();

  // Check for existing checkpoint
  const existingCheckpoint = findLatestFile("crossmodel-ratings-");
  let gptRatings: Array<{ rating: number; confidence: number }>;

  if (existingCheckpoint) {
    console.log(`Checkpoint found: ${path.basename(existingCheckpoint)}`);
    console.log("Loading existing GPT-4o ratings (skipping API calls)...\n");
    gptRatings = JSON.parse(fs.readFileSync(existingCheckpoint, "utf-8"));
  } else {
    // ─── Rate all 345 texts with GPT-4o ────────────────────────────
    console.log("Rating 345 Claude-generated texts with GPT-4o...\n");
    gptRatings = [];

    for (let i = 0; i < circularityData.cases.length; i++) {
      const c = circularityData.cases[i];
      const prompt = buildRatingPrompt(c.questionText, c.generatedText);

      let rating = 3;
      let confidence = 0.5;

      for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
          const text = await callGPT(openaiKey, prompt);
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            rating = Math.min(Math.max(Math.round(parsed.rating), 1), 5);
            confidence = Math.min(Math.max(parsed.confidence || 0.7, 0), 1);
            break;
          }
          console.error(`  Attempt ${attempt + 1}: No JSON in response for [${i}]`);
        } catch (err) {
          console.error(`  Attempt ${attempt + 1} failed for [${i}]:`, err);
          await delay(2000 * (attempt + 1));
        }
      }

      gptRatings.push({ rating, confidence });

      if ((i + 1) % 25 === 0 || i === circularityData.cases.length - 1) {
        const exact = rating === c.targetRating ? "EXACT" : `off by ${Math.abs(rating - c.targetRating)}`;
        console.log(
          `  [${i + 1}/${circularityData.cases.length}] ${c.testCaseLabel}/${c.personaId}: GPT=${rating}, target=${c.targetRating} [${exact}]`
        );
      }

      // Save intermediate checkpoint every 100 items
      if ((i + 1) % 100 === 0) {
        const partialPath = path.join(getDataDir(), `crossmodel-ratings-partial-${Date.now()}.json`);
        fs.writeFileSync(partialPath, JSON.stringify(gptRatings, null, 2));
        console.log(`  Checkpoint saved (${gptRatings.length} items)`);
      }

      if (i < circularityData.cases.length - 1) await delay(DELAY_MS);
    }

    // Save final ratings checkpoint
    const ratingsPath = path.join(getDataDir(), `crossmodel-ratings-${Date.now()}.json`);
    fs.writeFileSync(ratingsPath, JSON.stringify(gptRatings, null, 2));
    console.log(`\nSaved ${gptRatings.length} GPT-4o ratings to: ${path.basename(ratingsPath)}\n`);
  }

  // ─── Compute Metrics for All Three Conditions ──────────────────
  const targets = circularityData.cases.map((c) => c.targetRating);
  const withinModelRatings = circularityData.cases.map((c) => c.llmRating); // Claude→Claude
  const crossModelRatings = gptRatings.map((r) => r.rating); // Claude→GPT-4o
  const ssrRatings = circularityData.cases.map((c) => c.ssrRating); // Claude→SSR

  const withinModelMetrics = computeMetrics(withinModelRatings, targets);
  const crossModelMetrics = computeMetrics(crossModelRatings, targets);
  const ssrMetrics = computeMetrics(ssrRatings, targets);

  // ─── Results ───────────────────────────────────────────────────
  console.log("=".repeat(80));
  console.log("RESULTS — THREE-CONDITION COMPARISON (N=345)");
  console.log("=".repeat(80));
  console.log();

  const colName = 28;
  const colExact = 14;
  const colW1 = 14;
  const colMAE = 8;
  const colMSE = 10;
  const colSD = 8;
  const colVar = 10;

  const h =
    pad("Condition", colName) +
    pad("Exact%", colExact) +
    pad("+/-1%", colW1) +
    pad("MAE", colMAE) +
    pad("MeanErr", colMSE) +
    pad("SD", colSD) +
    pad("Var", colVar);
  console.log(h);
  console.log("-".repeat(h.length));

  for (const [label, m] of [
    ["Within-model (Claude→Claude)", withinModelMetrics],
    ["Cross-model (Claude→GPT-4o)", crossModelMetrics],
    ["Independent (Claude→SSR)", ssrMetrics],
  ] as [string, ConditionMetrics][]) {
    console.log(
      pad(label, colName) +
        pad(`${m.exactMatchPct}%`, colExact) +
        pad(`${m.withinOnePct}%`, colW1) +
        pad(m.mae.toFixed(3), colMAE) +
        pad(m.meanSignedError.toFixed(3), colMSE) +
        pad(m.sdError.toFixed(3), colSD) +
        pad(m.variance.toFixed(4), colVar)
    );
  }

  console.log();

  // ─── Variance Compression Analysis ─────────────────────────────
  console.log("=".repeat(80));
  console.log("VARIANCE COMPRESSION ANALYSIS");
  console.log("=".repeat(80));
  console.log();

  const withinVar = withinModelMetrics.variance;
  const crossVar = crossModelMetrics.variance;
  const ssrVar = ssrMetrics.variance;

  console.log(`  Within-model error variance:  ${withinVar.toFixed(4)}`);
  console.log(`  Cross-model error variance:   ${crossVar.toFixed(4)}`);
  console.log(`  SSR (independent) variance:   ${ssrVar.toFixed(4)}`);
  console.log();
  console.log(`  Ratios:`);
  console.log(`    Within/SSR:  ${(withinVar / ssrVar).toFixed(2)}x  (${(withinVar / ssrVar) < 1 ? "compressed" : "expanded"})`);
  console.log(`    Cross/SSR:   ${(crossVar / ssrVar).toFixed(2)}x  (${(crossVar / ssrVar) < 1 ? "compressed" : "expanded"})`);
  console.log(`    Within/Cross: ${(withinVar / crossVar).toFixed(2)}x`);
  console.log();

  if (crossVar > withinVar * 1.2) {
    console.log("  INTERPRETATION: Cross-model shows MORE variance than within-model.");
    console.log("  This supports the circularity hypothesis — within-model rating");
    console.log("  artificially compresses variance due to shared model internals.");
  } else if (Math.abs(crossVar - withinVar) / withinVar < 0.2) {
    console.log("  INTERPRETATION: Cross-model and within-model show SIMILAR variance.");
    console.log("  This suggests the compression is a general LLM property, not");
    console.log("  specific to within-model circularity.");
  } else {
    console.log("  INTERPRETATION: Cross-model shows LESS variance than within-model.");
    console.log("  Unexpected result — investigate further.");
  }
  console.log();

  // ─── Directional Bias Analysis ─────────────────────────────────
  console.log("=".repeat(80));
  console.log("DIRECTIONAL BIAS ANALYSIS");
  console.log("=".repeat(80));
  console.log();

  console.log(`  Within-model mean signed error: ${withinModelMetrics.meanSignedError.toFixed(3)}`);
  console.log(`  Cross-model mean signed error:  ${crossModelMetrics.meanSignedError.toFixed(3)}`);
  console.log(`  SSR mean signed error:          ${ssrMetrics.meanSignedError.toFixed(3)}`);
  console.log();

  // ─── Per-Target Rating Breakdown ───────────────────────────────
  console.log("=".repeat(80));
  console.log("PER-TARGET RATING BREAKDOWN");
  console.log("=".repeat(80));
  console.log();

  for (const target of [1, 2, 3, 4, 5]) {
    const indices = targets.map((t, i) => (t === target ? i : -1)).filter((i) => i >= 0);
    if (indices.length === 0) continue;

    const wRatings = indices.map((i) => withinModelRatings[i]);
    const cRatings = indices.map((i) => crossModelRatings[i]);
    const sRatings = indices.map((i) => ssrRatings[i]);

    const wMean = (wRatings.reduce((a, b) => a + b, 0) / wRatings.length).toFixed(2);
    const cMean = (cRatings.reduce((a, b) => a + b, 0) / cRatings.length).toFixed(2);
    const sMean = (sRatings.reduce((a, b) => a + b, 0) / sRatings.length).toFixed(2);

    const wExact = wRatings.filter((r) => r === target).length;
    const cExact = cRatings.filter((r) => r === target).length;
    const sExact = sRatings.filter((r) => r === target).length;

    console.log(`  Target = ${target} (N=${indices.length}):`);
    console.log(`    Within-model: mean=${wMean}, exact=${wExact}/${indices.length} (${Math.round((wExact / indices.length) * 100)}%)`);
    console.log(`    Cross-model:  mean=${cMean}, exact=${cExact}/${indices.length} (${Math.round((cExact / indices.length) * 100)}%)`);
    console.log(`    SSR:          mean=${sMean}, exact=${sExact}/${indices.length} (${Math.round((sExact / indices.length) * 100)}%)`);
    console.log();
  }

  // ─── Agreement Analysis ────────────────────────────────────────
  console.log("=".repeat(80));
  console.log("CROSS-MODEL AGREEMENT (Claude vs GPT-4o on same texts)");
  console.log("=".repeat(80));
  console.log();

  let agree = 0;
  let bothCorrect = 0;
  let onlyClaude = 0;
  let onlyGPT = 0;
  let neither = 0;

  for (let i = 0; i < targets.length; i++) {
    if (withinModelRatings[i] === crossModelRatings[i]) agree++;
    const cCorrect = withinModelRatings[i] === targets[i];
    const gCorrect = crossModelRatings[i] === targets[i];
    if (cCorrect && gCorrect) bothCorrect++;
    else if (cCorrect) onlyClaude++;
    else if (gCorrect) onlyGPT++;
    else neither++;
  }

  console.log(`  Same prediction:     ${agree}/${targets.length} (${Math.round((agree / targets.length) * 100)}%)`);
  console.log(`  Both correct:        ${bothCorrect}/${targets.length}`);
  console.log(`  Only Claude correct: ${onlyClaude}/${targets.length}`);
  console.log(`  Only GPT-4o correct: ${onlyGPT}/${targets.length}`);
  console.log(`  Neither correct:     ${neither}/${targets.length}`);
  console.log();

  // ─── Save Results ──────────────────────────────────────────────
  const output = {
    timestamp: new Date().toISOString(),
    description: "Cross-model circularity: GPT-4o rating 345 Claude-generated texts",
    config: {
      ratingModel: GPT_MODEL,
      generationModel: circularityData.metadata.config.generationModel,
      temperature: TEMPERATURE,
      nCases: circularityData.cases.length,
      sourceFile: path.basename(circularityFile),
    },
    gptRatings: gptRatings,
    metrics: {
      withinModel: withinModelMetrics,
      crossModel: crossModelMetrics,
      ssr: ssrMetrics,
    },
    varianceAnalysis: {
      withinModelVariance: withinVar,
      crossModelVariance: crossVar,
      ssrVariance: ssrVar,
      withinOverSSR: parseFloat((withinVar / ssrVar).toFixed(4)),
      crossOverSSR: parseFloat((crossVar / ssrVar).toFixed(4)),
      withinOverCross: parseFloat((withinVar / crossVar).toFixed(4)),
    },
    agreement: {
      samePrediction: agree,
      samePredictionPct: Math.round((agree / targets.length) * 100),
      bothCorrect,
      onlyClaudeCorrect: onlyClaude,
      onlyGPTCorrect: onlyGPT,
      neitherCorrect: neither,
    },
    perCase: circularityData.cases.map((c, i) => ({
      testCaseLabel: c.testCaseLabel,
      domain: c.domain,
      personaId: c.personaId,
      targetRating: c.targetRating,
      withinModelRating: c.llmRating,
      crossModelRating: gptRatings[i].rating,
      ssrRating: c.ssrRating,
    })),
  };

  const outputPath = path.join(getDataDir(), `crossmodel-circularity-${Date.now()}.json`);
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, JSON.stringify(output, null, 2));
  console.log(`Results saved to: ${outputPath}`);

  // ─── Paper Summary ─────────────────────────────────────────────
  console.log();
  console.log("=".repeat(80));
  console.log("PAPER SUMMARY");
  console.log("=".repeat(80));
  console.log();
  console.log("  Three-condition comparison (N=345 Claude-generated texts):");
  console.log(`    Within-model (Claude→Claude): ${withinModelMetrics.exactMatchPct}% exact, var=${withinVar.toFixed(4)}`);
  console.log(`    Cross-model  (Claude→GPT-4o): ${crossModelMetrics.exactMatchPct}% exact, var=${crossVar.toFixed(4)}`);
  console.log(`    Independent  (Claude→SSR):    ${ssrMetrics.exactMatchPct}% exact, var=${ssrVar.toFixed(4)}`);
  console.log();
  console.log(`  Variance ratio within/SSR:  ${(withinVar / ssrVar).toFixed(2)}x`);
  console.log(`  Variance ratio cross/SSR:   ${(crossVar / ssrVar).toFixed(2)}x`);
  console.log(`  Variance ratio within/cross: ${(withinVar / crossVar).toFixed(2)}x`);
  console.log();
}

main().catch(console.error);
